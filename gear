#!/usr/bin/env perl

use strict;
use FindBin qw($Script);
use POSIX qw(floor);

use constant KG_PER_OZ => 0.0283495231;

# modes
use constant {
    DB => 0,
    MANIFEST => 1
};

# states
use constant {
    SECTION => 0,
    ITEM => 1,
    FIELD => 2
};

our %opts = ();

use Getopt::Long;
Getopt::Long::Configure("bundling");
unless (GetOptions(
    \%opts,
    "help|h" => sub {print_usage();},
)) {
    print_usage();
};

print_usage() && exit() if (scalar(@ARGV) != 2);

my $section = "none";
my %db;
my %manifest;

my $section_weight = 0;
my %section_weights;

for (my $mode = 0; $mode < 2; $mode++) {
    my $file = shift;
    my $state = SECTION;

    open(my $fh, "<$file") or die("$Script: could not open file $file\n");

    for (my $ln = 1; <$fh>; $ln++) {
        if ($state == SECTION) {
            if (m/^\w+$/) {
                # section heading
                $section = $_;
                chomp($section);

                if ($mode == MANIFEST) {
                    $section_weight = 0;
                    print(uc());
                }

                $state = ITEM;
            } elsif (m/^\s$/) {
                # blank between sections
                next;
            } else {
                die("$Script: error - cannot parse section @ $file:$ln\n");
            }
        } elsif ($state == ITEM) {
            if (m/^\s$/) {
                # end current section -> next section
                if ($mode == MANIFEST) {
                    $section_weights{lc($section)} = $section_weight;
                    printf("%-34s %15s\n", "SUBTOTAL", sprint_weight($section_weight));
                    print();
                }
                $state = SECTION;
            } elsif ($mode == DB && m/;/) {
                # item
                process_db_line($_);
            } elsif ($mode == MANIFEST && m/^([+-]\d+)\s(.*$)/) {
                # item
                process_manifest_line($1, $2);
            } else {
                die("$Script: error - cannot parse item @ $file:$ln\n");
            }
        } elsif ($state == FIELD) {
            if (m/^\w$/) {
            }
        }
    }

    close($fh);
}

exit(0);

sub process_manifest_line {
    my ($count, $id) = @_;

    if ($id =~ /section::/) {
        # lookup section
        $id =~ s/section:://;
        die("$Script: section $id does not exist in db.\n") if (!exists($section_weights{$id}));
        my $weight = $count*$section_weights{$id};
        $section_weight += $weight;
        printf("%+3d %-30s %15s\n", $count, uc($id), sprint_weight(abs($weight)));
    } else {
        # lookup item
        #warn("$Script: id $id does not exist in db.\n") && return if (!exists($db{$id}));
        my $weight;
        my %item;
        if (exists($db{$id})) {
            %item = %{$db{$id}};
            $weight = $count*$item{w};
            $section_weight += $weight;
            $weight = sprint_weight(abs($weight));
        } else {
            $weight = "TBD";
        }
        printf("%+3d %-30s %15s", $count, sprint_id($id), $weight);
        printf(" -- %s", $item{d}) if (%item && exists($item{d}));
        print("\n");
    }
}

sub process_db_line {
    my ($line) = @_;

    my @fields = split(/;/, $line);

    my %item = (
        id => shift(@fields)
    );

    for my $field (@fields) {
        chomp($field);

        my ($is_meas, $meas_typ, $parse_func) = is_measure($field);

        if ($is_meas) {
            $item{$meas_typ} = &$parse_func($field);
        } else {
            $item{d} = $field;
        }
    }

    $db{$item{id}} = \%item;
}

sub is_measure {
    my ($str) = @_;
    
    if ($str =~ m/\doz$/) {
        return (1, 'w', \&parse_weight);
    } elsif ($str =~ m/\dlb$/) {
        return (1, 'w', \&parse_weight);
    } elsif ($str =~ m/\dmL$/) {
        return (1, 'v', \&parse_volume);
    } elsif ($str =~ m/\dL$/) {
        return (1, 'v', \&parse_volume);
    } elsif ($str =~ m/\dkcal$/) {
        return (1, 'cal', \&parse_energy);
    } elsif ($str =~ m/\dg fat$/) {
        return (1, 'fat', \&parse_fat);
    } elsif ($str =~ m/\dg carb$/) {
        return (1, 'carb', \&parse_carb);
    } elsif ($str =~ m/\dg fiber$/) {
        return (1, 'fiber', \&parse_fiber);
    } elsif ($str =~ m/\dg protein$/) {
        return (1, 'protein', \&parse_protein);
    }

    return 0;
}

# returns weight in kg
sub parse_weight {
    my ($txt) = @_;

    if ($txt =~ m/([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+))lb([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+))oz/) {
        return KG_PER_OZ*($1*16+$3);
    } elsif ($txt =~ m/([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+))oz/) {
        return KG_PER_OZ*($1);
    } elsif ($txt =~ m/([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+))lb/) {
        return KG_PER_OZ*($1*16);
    } else {
        die("$Script: unable to parse weight $txt\n");
    }
}

# returns volume in L
sub parse_volume {
    my ($txt) = @_;

    if ($txt =~ m/([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+))L/) {
        return $1;
    } elsif ($txt =~ m/([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+))mL/) {
        return $1/1000;
    } else {
        die("$Script: unable to parse volume $txt\n");
    }
}

sub sprint_id {
    my ($id) = @_;

    return join(' ', map {ucfirst($_)} split(/_|::/,$id));
}

sub sprint_weight {
    my ($kg) = @_;

    my $oz = $kg / KG_PER_OZ;
    my $lb = floor($oz/16);
    $oz -= $lb*16;

    return $lb ? sprintf("%dlb %.1foz", $lb, $oz) : sprintf("%.1foz", $oz);
}

sub debug {
    my ($s) = @_;
    print($s);
}

sub print_usage {
    print <<EOF
Usage: $Script <database> <list>
EOF
}


__DATA__

=head1 NAME

$Script - manage gear lists

=head1 SYNOPSIS

B<$Script> --help|-h

B<$Script> <database> <format>

=head1 OPTIONS

=over

=item B<--help|-h>

This message.

=back

=head1 DESCRIPTION

$Script takes a gear database and a gear format to create a gear list.

=cut
